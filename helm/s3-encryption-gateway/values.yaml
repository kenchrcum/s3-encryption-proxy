# Default values for s3-encryption-gateway
# This is a YAML-formatted file.

replicaCount: 1

image:
  repository: kenchrcum/s3-encryption-gateway
  pullPolicy: IfNotPresent
  tag: "0.3.10"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false

service:
  # Enable Service creation. Set to false if deploying multiple instances
  # in different namespaces or using alternative ingress methods.
  enabled: true
  type: ClusterIP
  port: 80
  targetPort: 8080

# Ingress configuration
ingress:
  enabled: false
  className: ""
  annotations:
    # kubernetes.io/ingress.class: nginx
    # cert-manager.io/cluster-issuer: letsencrypt-prod
    # nginx.ingress.kubernetes.io/ssl-redirect: "true"
    # nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    # nginx.ingress.kubernetes.io/proxy-body-size: "0"
    # nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
    # nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
  hosts:
    - host: s3-encryption-gateway.local
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: s3-encryption-gateway-tls
  #    hosts:
  #      - s3-encryption-gateway.local

# Configuration - supports both direct values and valueFrom (secrets/configmaps)
# Each option can be configured as:
#   - Direct value: value: "my-value"
#   - From Secret: valueFrom: { secretKeyRef: { name: "my-secret", key: "my-key" } }
#   - From ConfigMap: valueFrom: { configMapKeyRef: { name: "my-configmap", key: "my-key" } }

config:
  # Basic server configuration
  listenAddr:
    value: ":8080"
  logLevel:
    value: "info"
  
  # Proxied bucket configuration (optional - restricts gateway to single bucket)
  proxiedBucket:
    value: ""
    valueFrom: {}
    # Example:
    # value: "my-bucket"
    # Or use valueFrom:
    # valueFrom:
    #   secretKeyRef:
    #     name: s3-encryption-gateway-secrets
    #     key: proxied-bucket

  # Backend S3 configuration
  backend:
    endpoint:
      value: "https://s3.amazonaws.com"
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: backend-endpoint
    region:
      value: "us-east-1"
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: backend-region
    accessKey:
      value: ""
      valueFrom:
        secretKeyRef:
          name: s3-encryption-gateway-secrets
          key: backend-access-key
    secretKey:
      value: ""
      valueFrom:
        secretKeyRef:
          name: s3-encryption-gateway-secrets
          key: backend-secret-key
    provider:
      value: ""
      valueFrom: {}
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: backend-provider
    useSSL:
      value: "true"
    usePathStyle:
      value: "false"
    useClientCredentials:
      value: "false"
      valueFrom: {}
      # If set to "true", the gateway will extract and use credentials from client requests.
      # When enabled, backend.accessKey and backend.secretKey are NOT required.
      # Requests must include credentials via query parameters (AWSAccessKeyId, AWSSecretAccessKey)
      # or Authorization header. If credentials cannot be extracted, requests will fail.
      # Example:
      # value: "true"
      # Or use valueFrom:
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: backend-use-client-credentials

  # Encryption configuration
  encryption:
    password:
      value: ""
      valueFrom:
        secretKeyRef:
          name: s3-encryption-gateway-secrets
          key: encryption-password
    keyFile:
      value: ""
      valueFrom: {}
      # valueFrom:
      #   secretKeyRef:
      #     name: s3-encryption-gateway-secrets
      #     key: encryption-key-file
    preferredAlgorithm:
      value: "AES256-GCM"
      valueFrom: {}
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: encryption-preferred-algorithm
    supportedAlgorithms:
      value: "AES256-GCM,ChaCha20-Poly1305"
      valueFrom: {}
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: encryption-supported-algorithms
    keyManager:
      enabled:
        value: "false"
        # valueFrom:
        #   configMapKeyRef:
        #     name: s3-encryption-gateway-config
        #     key: key-manager-enabled

  # Compression configuration
  compression:
    enabled:
      value: "false"
    minSize:
      value: "1024"
    contentTypes:
      value: "text/plain,application/json,application/xml"
    algorithm:
      value: "gzip"
    level:
      value: "6"

  # Server timeout configuration
  server:
    readTimeout:
      value: "15s"
    writeTimeout:
      value: "15s"
    idleTimeout:
      value: "60s"
    readHeaderTimeout:
      value: "10s"
    maxHeaderBytes:
      value: "1048576"

  # TLS configuration
  tls:
    enabled:
      value: "false"
    # Enable cert-manager for automatic certificate management
    # When enabled, a self-signed certificate will be automatically created
    # and mounted into the pod. The certFile and keyFile will be automatically
    # configured to use the mounted certificate.
    useCertManager:
      value: "false"
    certFile:
      value: ""
      valueFrom: {}
      # valueFrom:
      #   secretKeyRef:
      #     name: s3-encryption-gateway-secrets
      #     key: tls-cert-file
    keyFile:
      value: ""
      valueFrom: {}
      # valueFrom:
      #   secretKeyRef:
      #     name: s3-encryption-gateway-secrets
      #     key: tls-key-file

  # Rate limiting configuration
  rateLimit:
    enabled:
      value: "false"
    limit:
      value: "100"
    window:
      value: "60s"

  # Cache configuration
  cache:
    enabled:
      value: "false"
    maxSize:
      value: "104857600"
    maxItems:
      value: "1000"
    defaultTTL:
      value: "5m"

  # Audit configuration
  audit:
    enabled:
      value: "false"
    maxEvents:
      value: "10000"

# cert-manager configuration
certManager:
  # Issuer configuration
  issuer:
    # Name for the issuer (defaults to fullname)
    name: ""
    # Namespace for the issuer (defaults to release namespace)
    namespace: ""
    # Self-signed issuer configuration
    selfSigned: {}
    # Or use ClusterIssuer instead (requires cluster-admin)
    # clusterIssuer: "letsencrypt-prod"
  # Certificate configuration
  certificate:
    # Additional DNS names for the certificate
    extraDNSNames: []
    # Certificate duration (default: 2160h = 90 days)
    duration: "2160h"
    # How long before expiry to renew (default: 720h = 30 days)
    renewBefore: "720h"

# Extra environment variables to add to the main container
extraEnv: []
# Example:
# extraEnv:
#   - name: MY_CUSTOM_VAR
#     value: "my-value"
#   - name: MY_SECRET_VAR
#     valueFrom:
#       secretKeyRef:
#         name: my-secret
#         key: my-key

# Extra volume mounts to add to the main container
extraVolumeMounts: []
# Example:
# extraVolumeMounts:
#   - name: my-config
#     mountPath: /etc/my-config
#     readOnly: true

# Extra volumes to add to the pod spec
extraVolumes: []
# Example:
# extraVolumes:
#   - name: my-config
#     configMap:
#       name: my-configmap
#   - name: my-secret
#     secret:
#       secretName: my-secret

# Init containers to run before the main container
initContainers: []
# Example:
# initContainers:
#   - name: init-myservice
#     image: busybox:1.35
#     command: ['sh', '-c', 'echo initializing...']
#     volumeMounts:
#       - name: my-volume
#         mountPath: /data

# Sidecar containers to run alongside the main container
sidecars: []
# Example:
# sidecars:
#   - name: sidecar-logger
#     image: fluent/fluent-bit:2.0
#     ports:
#       - containerPort: 2020
#     volumeMounts:
#       - name: varlogcontainers
#         mountPath: /var/log/containers
#         readOnly: true

resources:
  limits:
    cpu: 500m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 64Mi

livenessProbe:
  httpGet:
    path: /live
    port: http
  initialDelaySeconds: 10
  periodSeconds: 30
  timeoutSeconds: 3
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 3

autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 2
        periodSeconds: 15
      selectPolicy: Max

# Pod Disruption Budget
podDisruptionBudget:
  enabled: false
  # minAvailable: 1
  # maxUnavailable: 50%
  minAvailable: ""
  maxUnavailable: ""

# Prometheus ServiceMonitor (requires Prometheus Operator)
serviceMonitor:
  enabled: false
  interval: 30s
  scrapeTimeout: 10s
  labels: {}

# Prometheus PodMonitor (alternative to ServiceMonitor, requires Prometheus Operator)
podMonitor:
  enabled: false
  interval: 30s
  scrapeTimeout: 10s
  labels: {}

# Network policy
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress
  # Restrict ingress to same namespace only
  # When true, only pods in the same namespace can access the gateway
  # When false, pods from any namespace can access (default behavior)
  namespaceIsolation: true
  # Namespace label for isolation (optional)
  # If not specified, uses kubernetes.io/metadata.name (standard Kubernetes label)
  # Format: key: value (e.g., "kubernetes.io/metadata.name: my-namespace")
  # If your namespace doesn't have kubernetes.io/metadata.name, you can:
  # 1. Label your namespace: kubectl label namespace <name> name=<name>
  # 2. Or specify a custom label here
  namespaceLabel:
    key: "kubernetes.io/metadata.name"
    # value will be set to Release.Namespace automatically

nodeSelector: {}

tolerations: []

affinity: {}

# Topology spread constraints for pod distribution
topologySpreadConstraints: []
# Example:
# topologySpreadConstraints:
#   - maxSkew: 1
#     topologyKey: kubernetes.io/hostname
#     whenUnsatisfiable: DoNotSchedule
#     labelSelector:
#       matchLabels:
#         app.kubernetes.io/name: s3-encryption-gateway
#   - maxSkew: 1
#     topologyKey: topology.kubernetes.io/zone
#     whenUnsatisfiable: ScheduleAnyway
#     labelSelector:
#       matchLabels:
#         app.kubernetes.io/name: s3-encryption-gateway

