# Default values for s3-encryption-gateway
# This is a YAML-formatted file.

replicaCount: 1

image:
  repository: kenchrcum/s3-encryption-gateway
  pullPolicy: IfNotPresent
  tag: "0.3.1"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false

service:
  type: ClusterIP
  port: 80
  targetPort: 8080

# Configuration - supports both direct values and valueFrom (secrets/configmaps)
# Each option can be configured as:
#   - Direct value: value: "my-value"
#   - From Secret: valueFrom: { secretKeyRef: { name: "my-secret", key: "my-key" } }
#   - From ConfigMap: valueFrom: { configMapKeyRef: { name: "my-configmap", key: "my-key" } }

config:
  # Basic server configuration
  listenAddr:
    value: ":8080"
  logLevel:
    value: "info"
  
  # Proxied bucket configuration (optional - restricts gateway to single bucket)
  proxiedBucket:
    value: ""
    valueFrom: {}
    # Example:
    # value: "my-bucket"
    # Or use valueFrom:
    # valueFrom:
    #   secretKeyRef:
    #     name: s3-encryption-gateway-secrets
    #     key: proxied-bucket

  # Backend S3 configuration
  backend:
    endpoint:
      value: "https://s3.amazonaws.com"
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: backend-endpoint
    region:
      value: "us-east-1"
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: backend-region
    accessKey:
      value: ""
      valueFrom:
        secretKeyRef:
          name: s3-encryption-gateway-secrets
          key: backend-access-key
    secretKey:
      value: ""
      valueFrom:
        secretKeyRef:
          name: s3-encryption-gateway-secrets
          key: backend-secret-key
    provider:
      value: ""
      valueFrom: {}
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: backend-provider
    useSSL:
      value: "true"
    usePathStyle:
      value: "false"
    useClientCredentials:
      value: "false"
      valueFrom: {}
      # If set to "true", the gateway will extract and use credentials from client requests.
      # When enabled, backend.accessKey and backend.secretKey are NOT required.
      # Requests must include credentials via query parameters (AWSAccessKeyId, AWSSecretAccessKey)
      # or Authorization header. If credentials cannot be extracted, requests will fail.
      # Example:
      # value: "true"
      # Or use valueFrom:
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: backend-use-client-credentials

  # Encryption configuration
  encryption:
    password:
      value: ""
      valueFrom:
        secretKeyRef:
          name: s3-encryption-gateway-secrets
          key: encryption-password
    keyFile:
      value: ""
      valueFrom: {}
      # valueFrom:
      #   secretKeyRef:
      #     name: s3-encryption-gateway-secrets
      #     key: encryption-key-file
    preferredAlgorithm:
      value: "AES256-GCM"
      valueFrom: {}
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: encryption-preferred-algorithm
    supportedAlgorithms:
      value: "AES256-GCM,ChaCha20-Poly1305"
      valueFrom: {}
      # valueFrom:
      #   configMapKeyRef:
      #     name: s3-encryption-gateway-config
      #     key: encryption-supported-algorithms
    keyManager:
      enabled:
        value: "false"
        # valueFrom:
        #   configMapKeyRef:
        #     name: s3-encryption-gateway-config
        #     key: key-manager-enabled

  # Compression configuration
  compression:
    enabled:
      value: "false"
    minSize:
      value: "1024"
    contentTypes:
      value: "text/plain,application/json,application/xml"
    algorithm:
      value: "gzip"
    level:
      value: "6"

  # Server timeout configuration
  server:
    readTimeout:
      value: "15s"
    writeTimeout:
      value: "15s"
    idleTimeout:
      value: "60s"
    readHeaderTimeout:
      value: "10s"
    maxHeaderBytes:
      value: "1048576"

  # TLS configuration
  tls:
    enabled:
      value: "false"
    # Enable cert-manager for automatic certificate management
    # When enabled, a self-signed certificate will be automatically created
    # and mounted into the pod. The certFile and keyFile will be automatically
    # configured to use the mounted certificate.
    useCertManager:
      value: "false"
    certFile:
      value: ""
      valueFrom: {}
      # valueFrom:
      #   secretKeyRef:
      #     name: s3-encryption-gateway-secrets
      #     key: tls-cert-file
    keyFile:
      value: ""
      valueFrom: {}
      # valueFrom:
      #   secretKeyRef:
      #     name: s3-encryption-gateway-secrets
      #     key: tls-key-file

  # Rate limiting configuration
  rateLimit:
    enabled:
      value: "false"
    limit:
      value: "100"
    window:
      value: "60s"

  # Cache configuration
  cache:
    enabled:
      value: "false"
    maxSize:
      value: "104857600"
    maxItems:
      value: "1000"
    defaultTTL:
      value: "5m"

  # Audit configuration
  audit:
    enabled:
      value: "false"
    maxEvents:
      value: "10000"

# cert-manager configuration
certManager:
  # Issuer configuration
  issuer:
    # Name for the issuer (defaults to fullname)
    name: ""
    # Namespace for the issuer (defaults to release namespace)
    namespace: ""
    # Self-signed issuer configuration
    selfSigned: {}
    # Or use ClusterIssuer instead (requires cluster-admin)
    # clusterIssuer: "letsencrypt-prod"
  # Certificate configuration
  certificate:
    # Additional DNS names for the certificate
    extraDNSNames: []
    # Certificate duration (default: 2160h = 90 days)
    duration: "2160h"
    # How long before expiry to renew (default: 720h = 30 days)
    renewBefore: "720h"

resources:
  limits:
    cpu: 500m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 64Mi

livenessProbe:
  httpGet:
    path: /live
    port: http
  initialDelaySeconds: 10
  periodSeconds: 30
  timeoutSeconds: 3
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 3

autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 2
        periodSeconds: 15
      selectPolicy: Max

# Prometheus ServiceMonitor (requires Prometheus Operator)
serviceMonitor:
  enabled: false
  interval: 30s
  scrapeTimeout: 10s
  labels: {}

# Network policy
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress

nodeSelector: {}

tolerations: []

affinity: {}

